"use strict";
/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
const call_1 = require("./call");
const channel_1 = require("./channel");
const constants_1 = require("./constants");
const metadata_1 = require("./metadata");
const client_interceptors_1 = require("./client-interceptors");
const CHANNEL_SYMBOL = Symbol();
const INTERCEPTOR_SYMBOL = Symbol();
const INTERCEPTOR_PROVIDER_SYMBOL = Symbol();
/**
 * A generic gRPC client. Primarily useful as a base class for all generated
 * clients.
 */
class Client {
    constructor(address, credentials, options = {}) {
        var _a, _b;
        if (options.channelOverride) {
            this[CHANNEL_SYMBOL] = options.channelOverride;
        }
        else if (options.channelFactoryOverride) {
            this[CHANNEL_SYMBOL] = options.channelFactoryOverride(address, credentials, options);
        }
        else {
            this[CHANNEL_SYMBOL] = new channel_1.ChannelImplementation(address, credentials, options);
        }
        this[INTERCEPTOR_SYMBOL] = (_a = options.interceptors, (_a !== null && _a !== void 0 ? _a : []));
        this[INTERCEPTOR_PROVIDER_SYMBOL] = (_b = options.interceptor_providers, (_b !== null && _b !== void 0 ? _b : []));
        if (this[INTERCEPTOR_SYMBOL].length > 0 &&
            this[INTERCEPTOR_PROVIDER_SYMBOL].length > 0) {
            throw new Error('Both interceptors and interceptor_providers were passed as options ' +
                'to the client constructor. Only one of these is allowed.');
        }
    }
    close() {
        this[CHANNEL_SYMBOL].close();
    }
    getChannel() {
        return this[CHANNEL_SYMBOL];
    }
    waitForReady(deadline, callback) {
        const checkState = (err) => {
            if (err) {
                callback(new Error('Failed to connect before the deadline'));
                return;
            }
            let newState;
            try {
                newState = this[CHANNEL_SYMBOL].getConnectivityState(true);
            }
            catch (e) {
                callback(new Error('The channel has been closed'));
                return;
            }
            if (newState === channel_1.ConnectivityState.READY) {
                callback();
            }
            else {
                try {
                    this[CHANNEL_SYMBOL].watchConnectivityState(newState, deadline, checkState);
                }
                catch (e) {
                    callback(new Error('The channel has been closed'));
                }
            }
        };
        setImmediate(checkState);
    }
    checkOptionalUnaryResponseArguments(arg1, arg2, arg3) {
        if (arg1 instanceof Function) {
            return { metadata: new metadata_1.Metadata(), options: {}, callback: arg1 };
        }
        else if (arg2 instanceof Function) {
            if (arg1 instanceof metadata_1.Metadata) {
                return { metadata: arg1, options: {}, callback: arg2 };
            }
            else {
                return { metadata: new metadata_1.Metadata(), options: arg1, callback: arg2 };
            }
        }
        else {
            if (!(arg1 instanceof metadata_1.Metadata &&
                arg2 instanceof Object &&
                arg3 instanceof Function)) {
                throw new Error('Incorrect arguments passed');
            }
            return { metadata: arg1, options: arg2, callback: arg3 };
        }
    }
    makeUnaryRequest(method, serialize, deserialize, argument, metadata, options, callback) {
        var _a, _b;
        ({ metadata, options, callback } = this.checkOptionalUnaryResponseArguments(metadata, options, callback));
        const methodDefinition = {
            path: method,
            requestStream: false,
            responseStream: false,
            requestSerialize: serialize,
            responseDeserialize: deserialize,
        };
        const interceptorArgs = {
            clientInterceptors: this[INTERCEPTOR_SYMBOL],
            clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],
            callInterceptors: (_a = options.interceptors, (_a !== null && _a !== void 0 ? _a : [])),
            callInterceptorProviders: (_b = options.interceptor_providers, (_b !== null && _b !== void 0 ? _b : [])),
        };
        const call = client_interceptors_1.getInterceptingCall(interceptorArgs, methodDefinition, options, this[CHANNEL_SYMBOL]);
        if (options.credentials) {
            call.setCredentials(options.credentials);
        }
        const emitter = new call_1.ClientUnaryCallImpl(call);
        let responseMessage = null;
        let receivedStatus = false;
        call.start(metadata, {
            onReceiveMetadata: metadata => {
                emitter.emit('metadata', metadata);
            },
            // tslint:disable-next-line no-any
            onReceiveMessage(message) {
                if (responseMessage != null) {
                    call.cancelWithStatus(constants_1.Status.INTERNAL, 'Too many responses received');
                }
                responseMessage = message;
            },
            onReceiveStatus(status) {
                if (receivedStatus) {
                    return;
                }
                receivedStatus = true;
                if (status.code === constants_1.Status.OK) {
                    callback(null, responseMessage);
                }
                else {
                    callback(call_1.callErrorFromStatus(status));
                }
                emitter.emit('status', status);
            },
        });
        call.sendMessage(argument);
        call.halfClose();
        return emitter;
    }
    makeClientStreamRequest(method, serialize, deserialize, metadata, options, callback) {
        var _a, _b;
        ({ metadata, options, callback } = this.checkOptionalUnaryResponseArguments(metadata, options, callback));
        const methodDefinition = {
            path: method,
            requestStream: true,
            responseStream: false,
            requestSerialize: serialize,
            responseDeserialize: deserialize,
        };
        const interceptorArgs = {
            clientInterceptors: this[INTERCEPTOR_SYMBOL],
            clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],
            callInterceptors: (_a = options.interceptors, (_a !== null && _a !== void 0 ? _a : [])),
            callInterceptorProviders: (_b = options.interceptor_providers, (_b !== null && _b !== void 0 ? _b : [])),
        };
        const call = client_interceptors_1.getInterceptingCall(interceptorArgs, methodDefinition, options, this[CHANNEL_SYMBOL]);
        if (options.credentials) {
            call.setCredentials(options.credentials);
        }
        const emitter = new call_1.ClientWritableStreamImpl(call, serialize);
        let responseMessage = null;
        let receivedStatus = false;
        call.start(metadata, {
            onReceiveMetadata: metadata => {
                emitter.emit('metadata', metadata);
            },
            // tslint:disable-next-line no-any
            onReceiveMessage(message) {
                if (responseMessage != null) {
                    call.cancelWithStatus(constants_1.Status.INTERNAL, 'Too many responses received');
                }
                responseMessage = message;
            },
            onReceiveStatus(status) {
                if (receivedStatus) {
                    return;
                }
                receivedStatus = true;
                if (status.code === constants_1.Status.OK) {
                    callback(null, responseMessage);
                }
                else {
                    callback(call_1.callErrorFromStatus(status));
                }
                emitter.emit('status', status);
            },
        });
        return emitter;
    }
    checkMetadataAndOptions(arg1, arg2) {
        let metadata;
        let options;
        if (arg1 instanceof metadata_1.Metadata) {
            metadata = arg1;
            if (arg2) {
                options = arg2;
            }
            else {
                options = {};
            }
        }
        else {
            if (arg1) {
                options = arg1;
            }
            else {
                options = {};
            }
            metadata = new metadata_1.Metadata();
        }
        return { metadata, options };
    }
    makeServerStreamRequest(method, serialize, deserialize, argument, metadata, options) {
        var _a, _b;
        ({ metadata, options } = this.checkMetadataAndOptions(metadata, options));
        const methodDefinition = {
            path: method,
            requestStream: false,
            responseStream: true,
            requestSerialize: serialize,
            responseDeserialize: deserialize,
        };
        const interceptorArgs = {
            clientInterceptors: this[INTERCEPTOR_SYMBOL],
            clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],
            callInterceptors: (_a = options.interceptors, (_a !== null && _a !== void 0 ? _a : [])),
            callInterceptorProviders: (_b = options.interceptor_providers, (_b !== null && _b !== void 0 ? _b : [])),
        };
        const call = client_interceptors_1.getInterceptingCall(interceptorArgs, methodDefinition, options, this[CHANNEL_SYMBOL]);
        if (options.credentials) {
            call.setCredentials(options.credentials);
        }
        const stream = new call_1.ClientReadableStreamImpl(call, deserialize);
        let receivedStatus = false;
        call.start(metadata, {
            onReceiveMetadata(metadata) {
                stream.emit('metadata', metadata);
            },
            // tslint:disable-next-line no-any
            onReceiveMessage(message) {
                if (stream.push(message)) {
                    call.startRead();
                }
            },
            onReceiveStatus(status) {
                if (receivedStatus) {
                    return;
                }
                receivedStatus = true;
                stream.push(null);
                if (status.code !== constants_1.Status.OK) {
                    stream.emit('error', call_1.callErrorFromStatus(status));
                }
                stream.emit('status', status);
            },
        });
        call.sendMessage(argument);
        call.halfClose();
        return stream;
    }
    makeBidiStreamRequest(method, serialize, deserialize, metadata, options) {
        var _a, _b;
        ({ metadata, options } = this.checkMetadataAndOptions(metadata, options));
        const methodDefinition = {
            path: method,
            requestStream: true,
            responseStream: true,
            requestSerialize: serialize,
            responseDeserialize: deserialize,
        };
        const interceptorArgs = {
            clientInterceptors: this[INTERCEPTOR_SYMBOL],
            clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],
            callInterceptors: (_a = options.interceptors, (_a !== null && _a !== void 0 ? _a : [])),
            callInterceptorProviders: (_b = options.interceptor_providers, (_b !== null && _b !== void 0 ? _b : [])),
        };
        const call = client_interceptors_1.getInterceptingCall(interceptorArgs, methodDefinition, options, this[CHANNEL_SYMBOL]);
        if (options.credentials) {
            call.setCredentials(options.credentials);
        }
        const stream = new call_1.ClientDuplexStreamImpl(call, serialize, deserialize);
        let receivedStatus = false;
        call.start(metadata, {
            onReceiveMetadata(metadata) {
                stream.emit('metadata', metadata);
            },
            onReceiveMessage(message) {
                if (stream.push(message)) {
                    call.startRead();
                }
            },
            onReceiveStatus(status) {
                if (receivedStatus) {
                    return;
                }
                receivedStatus = true;
                stream.push(null);
                if (status.code !== constants_1.Status.OK) {
                    stream.emit('error', call_1.callErrorFromStatus(status));
                }
                stream.emit('status', status);
            },
        });
        return stream;
    }
}
exports.Client = Client;
//# sourceMappingURL=client.js.map